//!v1 oct2025
/*
[package]
name = "pieStatistic"
version = "1.0.0"
edition = "2024"

[dependencies]
image = "0.25.8"
tao = "0.34.3"
tray-icon = "0.21.1"
x11rb = "0.13.2"
sysinfo = "0.30" 
*/
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
use std::collections::HashMap;
use std::f64::consts::TAU;
use std::fs::{self, OpenOptions, read_to_string};
use std::io::{self, Write, BufWriter};
use std::time::{Duration,SystemTime,UNIX_EPOCH};
use std::thread;
use std::process::Command;
use x11rb::connection::Connection;
use x11rb::protocol::xproto::{AtomEnum, ConnectionExt};
use x11rb::rust_connection::RustConnection;
use sysinfo::{System, Pid, get_current_pid};
use std::sync::atomic::{AtomicU64, AtomicBool, Ordering};
use tray_icon::TrayIconBuilder;
use tray_icon::menu::{Menu, MenuEvent, MenuItem, PredefinedMenuItem};
use tao::event::Event;
use tao::event_loop::{ControlFlow,EventLoopBuilder};

enum UserEvent {
 MenuEvent(tray_icon::menu::MenuEvent),
 }

static timer: AtomicU64= AtomicU64::new(55);
static showPerformance: AtomicBool= AtomicBool::new(false);
static helpText: &str = "'help' '24h' 'all' 'setTime (secs)' 'clear' 'performance'\n(barGraph) █= 30 minutes\nsetTimer=";

fn performance() {
 if !showPerformance.load(Ordering::Relaxed){
  showPerformance.store(true,Ordering::Relaxed);
  thread::spawn(move || {
   let mut sys = System::new_all();
   let pid: Pid = get_current_pid().unwrap();
   while showPerformance.load(Ordering::Relaxed) {
    sys.refresh_process(pid);
    if let Some(process) = sys.process(pid) {
     let mem_bytes = process.memory();
     let mem_mb = mem_bytes as f64 / 1024.0 / 1024.0;
     println!(
      "This program -> CPU: {:.2}% | Memory: {:.2} MB",
      process.cpu_usage(),mem_mb);
     }
    thread::sleep( Duration::from_secs(timer.load(Ordering::Relaxed) / 15));
    }
   });
  } else {
  showPerformance.store(false, Ordering::Relaxed);
  }
 }

fn convert_time(secs: u64) -> (u64, u64, u64) {
 let hours = secs / 3600;
 let minutes = (secs % 3600) / 60;
 let seconds = secs % 60;
 (hours, minutes, seconds)
 }

fn reopen_in_terminal() {
 let currentExe = std::env::current_exe().expect("Failed to get current exe");
 eprintln!("Reopening in terminal: {}", currentExe.display());
 let terminals = [
  ("xdg-terminal-exec", vec![]), ("gnome-terminal", vec!["--"]), ("konsole", vec!["-e"]), ("xterm", vec!["-e"]), ("lxterminal", vec!["-e"]), ];
 for (term, arg) in terminals {
  let result = Command::new(term). 
   args(arg).arg(&currentExe).spawn();
  if result.is_ok() {
   eprintln!("Launched with {}", term);
   return;
   }
  }
 eprintln!("cantFindTerminal");
 }

fn getFocused() -> Option<(u32, String, String)> {
 let (conn, screen_num) = RustConnection::connect(None).ok()?;
 let screen = &conn.setup().roots[screen_num];
 let netActive = conn.intern_atom(
  false,b"_NET_ACTIVE_WINDOW") 
  .ok()?.reply().ok()?.atom;

 let net_wm_pid = conn.intern_atom(false, b"_NET_WM_PID").ok()?.reply().ok()?.atom;
 let wm_class = conn.intern_atom(false, b"WM_CLASS").ok()?.reply().ok()?.atom;
 let net_wm_name = conn.intern_atom(false, b"_NET_WM_NAME").ok()?.reply().ok()?.atom;
 let utf8_string = conn.intern_atom(false, b"UTF8_STRING").ok()?.reply().ok()?.atom;

 let reply= conn.get_property(false, screen.root,  
  netActive, AtomEnum::WINDOW, 0, 1).ok()?.reply().ok()?;
 let window = reply.value32()?.next()?;

 let mut pid: u32 = 0;
 if let Ok(reply) = conn.get_property(false, window, net_wm_pid, AtomEnum::CARDINAL, 0, 1).unwrap().reply() {
  if let Some(p) = reply.value32().and_then(|mut v| v.next()) {
   pid = p;
   }
  }
 let process_name = if pid > 0 {
  let exe = format!("/proc/{}/comm", pid);
  fs::read_to_string(exe).unwrap_or_else(|_| "unknown".to_string()).trim().to_string()
  } else {
  if let Ok(reply) = conn.get_property(false, window, wm_class, AtomEnum::STRING, 0, 64).unwrap().reply() {
   if !reply.value.is_empty() {
    let classes: Vec<&str> = reply.value.split
     (|&b| b == 0).filter_map
     (|s| std::str::from_utf8(s).ok()).collect();
    classes.first().unwrap_or(&"unknown").to_string()
    } else {
    "unknown".to_string()
    }
   } else {
   "unknown".to_string()
   }
  };
 let windowTitle = if let Ok(reply) =
  conn.get_property(false, window, net_wm_name, utf8_string, 0, u32::MAX).unwrap().reply(){
  if !reply.value.is_empty() {
   String::from_utf8(reply.value).unwrap_or_else(|_| "unknown".to_string())
   } else {
   "unknown".to_string()
   }
  } else {
  "unknown".to_string()
  };
 Some((pid, process_name, windowTitle))
 }

fn logTime() {
 thread::spawn(move || {
  loop {
   let mut all_totals: HashMap<String, u64> = HashMap::new();
   let mut history: Vec<String> = Vec::new();

   // Load existing file
   if let Ok(content) = read_to_string("log.txt") {
    let mut section = "";
    for line in content.lines() {
     if line.starts_with("[") {
      section = line.trim();
      }else if !line.is_empty() {
      match section {
       "[all]" => {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() == 2 {
         if let Ok(secs) = parts[1].parse::<u64>() {
          all_totals.insert(parts[0].to_string(), secs);
         }
        }
       }
       "[24h]" => {
        history.push(line.to_string());
       }
       _ => {}
      }
     }
    }
   }
  // getFocusTitle
  if let Some((_pid, process_name, windowTitle)) = getFocused() {
   let add_secs = timer.load(Ordering::Relaxed);
   let entry = all_totals.entry(process_name.clone()).or_insert(0);
   *entry += add_secs;
   let now = SystemTime::now().
duration_since(UNIX_EPOCH).unwrap_or(Duration::from_secs(0));
   let secs = now.as_secs();
   let mins = (secs / 60) % 60;
   let hours = (secs / 3600) % 24;
   let days = secs / 86400; // days since epoch, rough
   let line = format!("day{} {:02}:{:02} {} [{}] {}",
    days, hours, mins, process_name, windowTitle, add_secs);
   history.push(line);
   }
  let file = OpenOptions::new().create(true).write(true).truncate(true).open("log.txt").unwrap();
  let mut writer = BufWriter::new(file);
  writeln!(writer, "[all]").unwrap();
  for (name, secs) in &all_totals {
   writeln!(writer, "{} {}", name, secs).unwrap();
   }
  writeln!(writer, "\n[24h]").unwrap();
  for line in &history {
   writeln!(writer, "{}", line).unwrap();
   }
  writer.flush().unwrap();
   thread::sleep(Duration::from_secs(
   timer.load(Ordering::Relaxed)));
   }
  });
 }

fn save() {
 let value = timer.load(Ordering::Relaxed);
 let data = format!("setTimer: {}", value);
 if let Err(e) = fs::write("save.txt", data) {
  println!("Failed to write save.txt: {}", e);
  }
 }

fn load() {
 match fs::read_to_string("save.txt") {
  Ok(contents) => {
   if let Some(num_str) = contents.strip_prefix("setTimer:") {
    if let Ok(num) = num_str.trim().parse::<u64>() {
     timer.store(num, Ordering::Relaxed);
     println!("Loaded timer value: {}", num);
     return;
     }
    }
   println!("Invalid save format, using default: {}", timer.load(Ordering::Relaxed));
   }
  Err(_) => {
   println!("No save.txt found, using default: {}", timer.load(Ordering::Relaxed));
   return; // break out if no file
   }
  }
 }
 
fn barGraph() {
 let slotSecs: u64 = 24 * 60 * 60 / 60; // 60 slots
 let mut slots: Vec<String> = vec!["none".to_string(); 60];
 let mut totals: HashMap<String, u64> = HashMap::new();
 if let Ok(content) = read_to_string("log.txt") {
  let mut section = "";
  for line in content.lines() {
   if line.starts_with("[") {
    section = line.trim();
    } else if !line.is_empty() && section == "[24h]" {
    let parts: Vec<&str> = line.split_whitespace().collect();
    if parts.len() >= 4 {
     if let Ok(secs) = parts.last().unwrap().parse::<u64>() {
      let program = parts[2].to_string();      
      totals.entry(program.clone()).or_insert(0);
      let hh: u64 = parts[1][..2].parse().unwrap_or(0);
      let mm: u64 = parts[1][3..5].parse().unwrap_or(0);
      let start_sec = hh * 3600 + mm * 60;
      let end_sec = start_sec + secs;
      let start_slot = (start_sec / slotSecs).min(59) as usize;
      let end_slot = (end_sec / slotSecs).min(59) as usize;
      for i in start_slot..=end_slot {
       slots[i] = program.clone();
       }

      *totals.get_mut(&program).unwrap() += secs;
      }
     }
    }
   }
  }
 let mut color_map: HashMap<String, &str> =  HashMap::new();
 let colors = ["\x1b[31m", "\x1b[33m", "\x1b[32m", "\x1b[36m", "\x1b[34m", "\x1b[35m"];
 let mut color_idx = 0;
 for program in totals.keys() {
  if !color_map.contains_key(program) {
   let c = colors[color_idx % colors.len()];
   color_map.insert(program.clone(), c);
   color_idx += 1;
   }
  }
 if slots.iter().any(|s| s == "none") {
  color_map.insert("none".to_string(), "\x1b[37m");
  }
 for slot in &slots {
  print!("{}█\x1b[0m", color_map[slot]);
  }
 println!();
 println!("\nLegend (totals in hh:mm:ss):");
 let mut items: Vec<_> = totals.iter().collect();
 items.sort_by(|a,b| b.1.cmp(a.1)); 
 for (program, secs) in items {
  let h = secs / 3600;
  let m = (secs % 3600) / 60;
  let s = secs % 60;
  println!("{}█\x1b[0m {:<15} {:02}:{:02}:{:02}", color_map[program], program, h, m, s);
  }
 if slots.iter().any(|s| s == "none") {
  println!("{}█\x1b[0m none", color_map["none"]);
  }
 }

fn pieGraph() {
 let mut totals: HashMap<String, u64> = HashMap::new();
 if let Ok(content) = read_to_string("log.txt") {
  let mut section = "";
  for line in content.lines() {
   if line.starts_with("[") {
    section = line.trim();
    } else if !line.is_empty() && section == "[all]" {
    let parts: Vec<&str> = line.split_whitespace().collect();
    if parts.len() == 2 {
     if let Ok(secs) = parts[1].parse::<u64>() {
      totals.insert(parts[0].to_string(), secs);
      }
     }
    }
   }
  }
 if totals.is_empty() {
  println!("No data found.");
  return;
  }
 let mut sorted: Vec<(String, u64)> = totals.into_iter().collect();
 sorted.sort_by(|a, b| b.1.cmp(&a.1));
 let top: Vec<(String, u64)> = sorted.into_iter().take(5).collect();

 let totalTime: u64 = top.iter().map(|(_, t)| t).sum();
 if totalTime == 0 {
  println!("No time logged.");
  return;
  }
 let mut wedge_sizes = Vec::new();
 for (_, t) in &top {
  let frac = (*t as f64) / (totalTime as f64);
  wedge_sizes.push(frac * TAU);
  }

 let mut wedges = Vec::new();
 let mut acc = 0.0;
 for size in wedge_sizes {
  let start = acc;
  let end = acc + size;
  wedges.push((start, end));
  acc = end;
  }
 let (h,m,s)= convert_time(totalTime);
 println!("totalTime: {}:{}:{}", h,m,s);
 let radius: i32 = 6;
 let x_scale: f64 = 2.0;
 for y in -radius..=radius {
  for x in -(radius as f64 * x_scale).round() as i32..=(radius as f64 * x_scale).round() as i32 {
   let dx = (x as f64) / x_scale;
   let dy = y as f64;
   if dx * dx + dy * dy <= (radius as f64) * (radius as f64) {
    let mut angle = dy.atan2(dx); // -PI..PI
    if angle < 0.0 { angle += TAU; }
    let mut idx = 0;
    for (i, (start, end)) in wedges.iter().enumerate() {
     if angle >= *start && angle < *end {
      idx = i;
      break;
      }
     }
    let color_code = match idx % 6 {
     0 => 31, // red
     1 => 33, // yellow
     2 => 32, // green
     3 => 36, // cyan
     4 => 34, // blue
     _ => 35, // magenta
     };
    print!("\x1b[{}m█\x1b[0m", color_code);
    } else {
    print!(" ");
    }
   }
  println!();
  }
 println!("\nlegend:");
 for (i, (name, secs)) in top.iter().enumerate() {
  let color_code = match i % 6 {
   0 => 31,
   1 => 33,
   2 => 32,
   3 => 36,
   4 => 34,
   _ => 35,
   };
  let (h,m,s)= convert_time(*secs);
  println!("\x1b[{}m█\x1b[0m {} - {}:{}:{}", color_code, name, h,m,s);
  }
 }

fn loadIcon(path: &std::path::Path) -> tray_icon::Icon {
 let (icon_rgba, icon_width, icon_height) = {
  let image = image::open(path). expect("Failed to open icon path"). into_rgba8();
  let (width, height) = image.dimensions();
  let rgba = image.into_raw();
  (rgba, width, height)
  };
 tray_icon::Icon::from_rgba(icon_rgba, icon_width, icon_height).expect("Failed to open icon")
 }

fn trayIcon(){
 let path = concat!(env!("CARGO_MANIFEST_DIR"), "/icon.png");
 let event_loop = EventLoopBuilder::<UserEvent>::with_user_event().build();
 tray_icon::TrayIconEvent::set_event_handler(Some(move |_event| {}));

 let proxy = event_loop.create_proxy();
 MenuEvent::set_event_handler(Some(move |event| {
 let _ = proxy.send_event(UserEvent::MenuEvent(event));
 }));
 let tray_menu = Menu::new();
 let open_i = MenuItem::new("Open", true, None);
 let quit_i = MenuItem::new("Quit", true, None);
 let _ = tray_menu.append_items(&[&open_i,&PredefinedMenuItem::separator(), &quit_i,]);
 let mut tray_icon = None;
 event_loop.run(move |event, _, control_flow| {
  *control_flow = ControlFlow::Wait;
  match event {
   Event::NewEvents(tao::event::StartCause::Init) => {
    let icon = loadIcon(std::path::Path::new(path));
    tray_icon = Some(TrayIconBuilder::new()
     .with_menu(Box::new(tray_menu.clone())). with_tooltip("tao - awesome windowing lib"). with_icon(icon).build().unwrap(),);
    }
   Event::UserEvent(UserEvent::MenuEvent(event)) => {
    if event.id == open_i.id() {
     reopen_in_terminal();
     std::process::exit(0);
     }else if event.id == quit_i.id() {
     tray_icon.take();
     *control_flow = ControlFlow::Exit;
     }else if event.id == open_i.id() {
     use std::process::Command;
     let _ = Command::new("xterm"). arg("-e"). arg("bash -c 'echo Hello from tray!; exec bash'"). spawn();
     }
    }
   _ => {}
   }
  })
 }

fn commands() {
 thread::spawn(move || {
  let mut input = String::new();
  loop {
   print!("> ");
   io::stdout().flush().unwrap();
   input.clear();
   if io::stdin().read_line(&mut input).is_err() {
    break;
   }
   let cmd = input.trim().to_string();
   let parts: Vec<&str> = cmd.split_whitespace().collect();
   if parts.is_empty() {
    continue;
   }
   match parts[0] {
    "help" => {
     println!( "{}{}",helpText,timer.load(Ordering::Relaxed));
     }
    "setTimer" => {
     if parts.len() > 1 {
      if let Ok(num) = parts[1].parse::<u64>() {
       println!("set time to {}\nwill update in {} seconds", num,timer.load(Ordering::Relaxed));
       timer.store(num, Ordering::Relaxed);
       save();
       } else {
       println!("wrong number: {}", parts[1]);
       }
      } else {
      println!("use: setTimer <number>");
      }
     }
    "all" => {
     pieGraph();
     }
    "24h" => {
     barGraph();
     }
    "clear" => {
     print!("\x1B[2J\x1B[H");
     io::stdout().flush().unwrap();
     }
    "performance" => {
     performance();
     }
    other => {
     println!("wrong: {}", other);
     }
    }
   }
  });
 }

fn main() {
 load();
 println!("> help\n{}{}", helpText,timer.load(Ordering::Relaxed));
 logTime();
 commands();
 trayIcon();
 }
